import warningswarnings.filterwarnings("ignore")import pandas as pdimport matplotlib.pyplot as pltimport numpy as npimport randomimport numpy.random as rngfrom math import pifrom math import sinfrom math import cosfrom math import sqrtvaluesOfN=[10,50,100,500] + [1000*k for k in range(0,1001,50)]valuesOfN.remove(0)def throwing_needles(numberOfNeedles=50):    """    Simulation of "numberOfNeedles" needles being thrown    """    numberOfNeedlesCrossing=0    needles=np.random.rand(numberOfNeedles,2)    needles=np.dot(needles,np.array([[0.5,0],[0,pi/2]]))    numberOfNeedlesCrossing=np.sum(np.array(list(map( lambda x : 1 if x[0]<0.25*sin(x[1]) else 0 ,  needles ))))    return (2*0.5*numberOfNeedles)/(1*numberOfNeedlesCrossing)def monitoring_evolution_needles(valuesOfN,figure="Proba"):    """    Monitoring the evolution of the ratio of Buffon's needles problem    by increasing the number of needles and visualising if that ratio approches pi    """    pi_values = np.array([pi for i in range(len(valuesOfN))])    listOfProba = np.array(list(map(throwing_needles,valuesOfN)))    zero_values=np.array([0 for i in range(len(valuesOfN))])    fig,axp=plt.subplots(figsize=(15,10))    if figure=="Proba":        axp.plot(valuesOfN, pi_values,linestyle='--',label='Value of Pi')        axp.plot(valuesOfN, listOfProba,label='Approximation',c='r')        axp.set_ylabel("Buffon Ratio vs Pi")    elif figure=="Relative Error":        axp.plot(valuesOfN, np.absolute ((pi_values-listOfProba)/pi_values),label='Relative Error',c='r')        axp.plot(valuesOfN, zero_values,linestyle='--',label='Value of 0')    axp.set_xlabel("Number of Needles")    axp.legend(loc="upper right")    axp.locator_params(nbins = 20)    df=pd.DataFrame(listOfProba,valuesOfN)    df.reset_index(inplace=True)    df.rename(columns={'index' : 'Value of N', 0 : 'Approximation'},inplace=True)    plt.xscale(value='log')    return dfdef generate_figure(numberOfStripes=5,numberOfNeedles=50):        """        Generating a figure containing a square with a surface equaling to 1        inside of which there are rectangles of alternating colors.        In our context, this graph is the aiming target of the needle        """        L=0.5        T=1        Sq = np.linspace(-5,5,100)        cst = np.array([5 for i in range(100)])        fig,ax=plt.subplots(figsize=(10,10))        ax.plot(Sq,cst,color='black')        ax.plot(cst,Sq,color='black')        ax.plot(Sq,-cst,color='black')        ax.plot(-cst,Sq,color='black')        for i in range (numberOfStripes):            ax.add_patch(plt.Rectangle((-5+10*i/numberOfStripes,-5),5/(numberOfStripes),10,facecolor='black'))        needles=np.random.rand(numberOfNeedles,3)        needles=np.dot(needles,np.array([[0.5,0,0],[0,pi/2,0],[0,0,9]]))+np.array([[0,0,-4.5] for i in range(numberOfNeedles)])        for n in needles:            stripe=random.randint(-5,5) # we choose which stripe will be the closest            if stripe ==5 :                 side=-1            elif stripe == -5 :                side =1            else:                side=random.choice([-1,1]) # -1 is left, 1 is right            height=n[2]            theta=n[1]            width=stripe +side*n[0]            ax.scatter([width],[height],color='r',marker='x',zorder=2)            x1= width - sin(theta)*(L/2)            y1= height + cos(theta)*(L/2)            x2= width + sin(theta)*(L/2)            y2= height - cos(theta)*(L/2)            ax.plot([x1,x2],[y1,y2],c='r',zorder=2)                                                if __name__ == "__main__":    #df2=monitoring_evolution_needles(valuesOfN, figure="Relative Error")    df2=monitoring_evolution_needles(valuesOfN)    #generate_figure()                                                                                    